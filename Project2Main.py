# -*- coding: utf-8 -*-
"""project2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sxfAJ3NIIkz3KSsEOG4Gm_10bm745K_P
"""

import requests
import pandas as pd
import datetime
import numpy as np
from IPython import display # for updating the cell dynamically

def make_request(endpoint, payload=None):
    """
    Make a request to a specific endpoint on the weather API
    passing headers and optional payload.
    
    Parameters:
        - endpoint: The endpoint of the API you want to 
                    make a GET request to.
        - payload: A dictionary of data to pass along 
                   with the request.
    
    Returns:
        Response object.
    """
    return requests.get(
        f'https://www.ncdc.noaa.gov/cdo-web/api/v2/{endpoint}',
        headers={
            'token': 'UnEKmlXMamzVGuKAlGHAyBGoqeBOPwir'
        },
        params=payload
    )

startdates = np.arange(1876,2019)

results = []


for i in range(len(startdates) + 1):

    display.display(f'Gathering data for {str(startdates[i])}')
    
    response = make_request(
    'data', 
        {
        'datasetid' : 'GHCND', # Global Historical Climatology Network - Daily (GHCND) dataset
        'stationid' : 'GHCND:GM000003319', # Berlin, Germany
        'datatypeid': ('TMAX', 'TMIN'), 
        'startdate' : datetime.date(startdates[i], 1, 1),
        'enddate' : datetime.date(startdates[i], 12, 31),
        'units' : 'metric',
        'limit' : 1000 # max allowed
        }
    )
    if response.ok:
        # we extend the list instead of appending to avoid getting a nested list
        results.extend(response.json()['results'])

#creating Pandas dataframe from results
df = pd.DataFrame(results)

#checking to see if data looks good
df

#saving data to csv for download if you want
df.to_csv('berlin_dailytemps_1876-2019.csv', index=False)

#Moving TMAX and TMIN into separate columns
data_adjusted = df.pivot(index='date', columns='datatype', values='value').reset_index().rename_axis(None, axis=1)
data_adj2 = data_adjusted.set_index(pd.DatetimeIndex(data_adjusted['date']))

# Parse datestring into separate columns
data_adj2['Year'] = pd.to_datetime(data_adj2['date']).dt.year
data_adj2['Month'] = pd.to_datetime(data_adj2['date']).dt.month
data_adj2['Week_of_Year'] = pd.to_datetime(data_adj2['date']).dt.week
data_adj2['Day'] = pd.to_datetime(data_adj2['date']).dt.day
data_adj2['Time'] = pd.to_datetime(data_adj2['date']).dt.time

# Read in TMAX/TMIN values
TMAX = data_adj2['TMAX']
TMIN = data_adj2['TMIN']

# Calculate daily-averaged temperatures
Temp_DailyAveraged = (TMAX + TMIN)/2
data_adj2['Temp_DailyAveraged'] = Temp_DailyAveraged

# Group Daily-averaged temperatures by Year/Month, then Average
Temp_YearlyAveraged = data_adj2.groupby(['Year'], as_index=False)['Temp_DailyAveraged'].mean()
Temp_MonthlyAveraged = data_adj2.groupby(['Year','Month'], as_index=False)['Temp_DailyAveraged'].mean()
Temp_WeeklyAveraged = data_adj2.groupby(['Year','Week_of_Year'], as_index=False)['Temp_DailyAveraged'].mean()

# 1971-2000 Average
Temp_LongTermMean = data_adj2[(data_adj2['Year'] > 1970) & (data_adj2['Year'] < 2001)]['Temp_DailyAveraged'].mean()

# 1901-2000 STDs
Temp_LongerTermYearlyMean = data_adj2[(data_adj2['Year'] > 1900) & (data_adj2['Year'] < 2001)].groupby(['Year'], as_index=False)['Temp_DailyAveraged'].mean()
Temp_LongerTermYearlyMean_STD = np.std(Temp_LongerTermYearlyMean.values[:,1])
Temp_LongerTermMonthlyMean = data_adj2[(data_adj2['Year'] > 1900) & (data_adj2['Year'] < 2001)].groupby(['Year','Month'], as_index=False)['Temp_DailyAveraged'].mean()
Temp_LongerTermMonthlyMean_STD = np.std(Temp_LongerTermMonthlyMean.values[:,1])
Temp_LongerTermWeeklyMean = data_adj2[(data_adj2['Year'] > 1900) & (data_adj2['Year'] < 2001)].groupby(['Year','Week_of_Year'], as_index=False)['Temp_DailyAveraged'].mean()
Temp_LongerTermWeeklyMean_STD = np.std(Temp_LongerTermWeeklyMean.values[:,1])

# Calculate Normalized Anomalies
Temp_YearlyAveragedNormalizedAnomalies = (Temp_YearlyAveraged.values[:,1] - Temp_LongTermMean)/Temp_LongerTermYearlyMean_STD
Temp_MonthlyAveragedNormalizedAnomalies = (Temp_MonthlyAveraged.values[:,1] - Temp_LongTermMean)/Temp_LongerTermMonthlyMean_STD
Temp_WeeklyAveragedNormalizedAnomalies = (Temp_WeeklyAveraged.values[:,1] - Temp_LongTermMean)/Temp_LongerTermWeeklyMean_STD

####Plot Flags####

#Plot yearly, monthly, or weekly averages?
time_period = 'y' #enter y, m, or w or yearly, monthly, or weekly

#Overlay line plot on top of color stripes?
overlay = 'y' #enter y for yes, n for no

####End Plot Flags####


#selecting dataset to plot
if(time_period) == 'y':
    temp_data = Temp_YearlyAveragedNormalizedAnomalies
    tick_int = 10
elif(time_period) == 'm':
    tick_int = 120
    temp_data = Temp_MonthlyAveragedNormalizedAnomalies
elif(time_period) == 'w':
    temp_data = Temp_WeeklyAveragedNormalizedAnomalies
    tick_int = 520

#determining y bounds for plots
temp_max = max(temp_data)
temp_min = min(temp_data)
max_tot = max(np.abs([temp_max,temp_min]))

print('Max Value: ' , temp_max)
print('Min Value: ' , temp_min)


#plotting barcode graph with temp_data
fig , ax1 = plt.subplots(figsize=(20,10))

im = ax1.imshow(temp_data.reshape(1, -1), aspect = 'auto', cmap = 'seismic', 
                vmin = -2.5, vmax = 2.5) 
                
                #used if there isn't a single outlier data point that ruins everything
                #vmin = ((max_tot * -1) - (max_tot) * 0.1), 
                #vmax = (max_tot + max_tot * 0.1))
                
ax1.set_yticks([])

#adding line plot on top of graph
if overlay == 'y':
    ax2 = ax1.twinx()
    ax2.plot(temp_data,color='yellow',linewidth = 3, marker = 'o', markersize = 10)
    ax2.set_xticks(np.arange(0,len(temp_data),tick_int))
    ax2.set_xticklabels(np.arange(startdates[0],startdates[-1],10))
    ax2.set_ylim(((max_tot * -1) - (max_tot) * 0.1), (max_tot + max_tot * 0.1))
    ax2.yaxis.set_ticks_position('left')
elif overlay == 'n':
    ax1.set_xticks(np.arange(0,len(temp_data),10))
    ax1.set_xticklabels(np.arange(startdates[0],startdates[-1],10))

#fig.colorbar(im)
plt.xlim(0,len(temp_data))
plt.show()
