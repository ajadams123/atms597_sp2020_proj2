# -*- coding: utf-8 -*-
"""project2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sxfAJ3NIIkz3KSsEOG4Gm_10bm745K_P
"""

import requests
import pandas as pd
import datetime
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython import display # for updating the cell dynamically

## Setting API request 
def make_request(endpoint, payload=None):
    """
    Make a request to a specific endpoint on the weather API
    passing headers and optional payload.
    
    Parameters:
        - endpoint: The endpoint of the API you want to 
                    make a GET request to.
        - payload: A dictionary of data to pass along 
                   with the request.
    
    Returns:
        Response object.
    """
    return requests.get(
        f'https://www.ncdc.noaa.gov/cdo-web/api/v2/{endpoint}',
        headers={
            'token': 'UnEKmlXMamzVGuKAlGHAyBGoqeBOPwir'
        },
        params = payload
    )

## Range of years you wish to plot
startdates = np.arange(1876, 2019) # year range for Berlin, Germany dataset

results = []

## Looping through the given date range, collecting a full year with each API call
for i in range(len(startdates) + 1):

    display.display(f'Gathering data for {str(startdates[i])}')
    
    response = make_request(
    'data', 
        {
        'datasetid' : 'GHCND', # Global Historical Climatology Network - Daily (GHCND) dataset
        'stationid' : 'GHCND:GM000003319', # Berlin, Germany
        'datatypeid': ('TMAX', 'TMIN'),
        'startdate' : datetime.date(startdates[i], 1, 1),
        'enddate' : datetime.date(startdates[i], 12, 31),
        'units' : 'metric',
        'limit' : 1000 # max allowed
        }
    )
    if response.ok:
        # list extended instead of appended to avoid getting a nested list
        results.extend(response.json()['results'])

## Loading results into a Pandas dataframe and checking how it looks
df = pd.DataFrame(results)
df

## Moving TMAX and TMIN into separate columns
data_adjusted = df.pivot(index = 'date', columns = 'datatype', values = 'value').reset_index().rename_axis(None, axis = 1)
data_adj2 = data_adjusted.set_index(pd.DatetimeIndex(data_adjusted['date']))

## Parsing datestring into separate columns
data_adj2['Year'] = pd.to_datetime(data_adj2['date']).dt.year
data_adj2['Month'] = pd.to_datetime(data_adj2['date']).dt.month
data_adj2['Week_of_Year'] = pd.to_datetime(data_adj2['date']).dt.week
data_adj2['Day'] = pd.to_datetime(data_adj2['date']).dt.day
data_adj2['Time'] = pd.to_datetime(data_adj2['date']).dt.time

## Checking dataframe to see if fields were changed properly
data_adj2

## Saving to csv if you wish to download the data
data_adj2.to_csv('berlin_dailytemps_1876-2019.csv')

## Reading in TMAX & TMIN values
TMAX = data_adj2['TMAX']
TMIN = data_adj2['TMIN']

## Calculate daily-averaged temperatures
Temp_DailyAveraged = (TMAX + TMIN)/2
data_adj2['Temp_DailyAveraged'] = Temp_DailyAveraged

## Group Daily-averaged temperatures by Year or Month or Week, then average
Temp_YearlyAveraged = data_adj2.groupby(['Year'], as_index = False)['Temp_DailyAveraged'].mean()
Temp_MonthlyAveraged = data_adj2.groupby(['Year', 'Month'], as_index = False)['Temp_DailyAveraged'].mean()
Temp_WeeklyAveraged = data_adj2.groupby(['Year', 'Week_of_Year'], as_index = False)['Temp_DailyAveraged'].mean()

## 1971-2000 Average using daily-averaged temperatures
Temp_LongTermMean = data_adj2[(data_adj2['Year'] > 1970) & (data_adj2['Year'] < 2001)]['Temp_DailyAveraged'].mean()

## 1901-2000 Standard Deviations for Yearly-, Monthly-, or Weekly-averaged temperatures
Temp_LongerTermYearlyMean = data_adj2[(data_adj2['Year'] > 1900) & (data_adj2['Year'] < 2001)].groupby(['Year'], as_index = False)['Temp_DailyAveraged'].mean()
Temp_LongerTermYearlyMean_STD = np.std(Temp_LongerTermYearlyMean.values[:, 1])
Temp_LongerTermMonthlyMean = data_adj2[(data_adj2['Year'] > 1900) & (data_adj2['Year'] < 2001)].groupby(['Year', 'Month'], as_index = False)['Temp_DailyAveraged'].mean()
Temp_LongerTermMonthlyMean_STD = np.std(Temp_LongerTermMonthlyMean.values[:, 1])
Temp_LongerTermWeeklyMean = data_adj2[(data_adj2['Year'] > 1900) & (data_adj2['Year'] < 2001)].groupby(['Year', 'Week_of_Year'], as_index = False)['Temp_DailyAveraged'].mean()
Temp_LongerTermWeeklyMean_STD = np.std(Temp_LongerTermWeeklyMean.values[:, 1])

## Calculate Normalized Anomalies using respective 1901-2000 standard deviation
Temp_YearlyAveragedNormalizedAnomalies = (Temp_YearlyAveraged.values[:, 1] - Temp_LongTermMean) / Temp_LongerTermYearlyMean_STD
Temp_MonthlyAveragedNormalizedAnomalies = (Temp_MonthlyAveraged.values[:, 1] - Temp_LongTermMean) / Temp_LongerTermMonthlyMean_STD
Temp_WeeklyAveragedNormalizedAnomalies = (Temp_WeeklyAveraged.values[:, 1] - Temp_LongTermMean) / Temp_LongerTermWeeklyMean_STD

###############################################################################################################################
####Plot Flags####

## Plot yearly, monthly, or weekly averages?
time_period = 'y' #enter y, m, or w for yearly, monthly, or weekly

## Overlay line plot on top of color stripes?
overlay = 'y' #enter y for yes, n for no

####End Plot Flags####


## Selecting dataset to plot
if(time_period) == 'y':
    temp_data = Temp_YearlyAveragedNormalizedAnomalies
    tick_int = 10
    fig_width = 20
    fig_height = 10
elif(time_period) == 'm':
    tick_int = 120
    temp_data = Temp_MonthlyAveragedNormalizedAnomalies
    fig_width = 30
    fig_height = 5
elif(time_period) == 'w':
    temp_data = Temp_WeeklyAveragedNormalizedAnomalies
    tick_int = 520
    fig_width = 50
    fig_height = 3

## Determining y bounds for plotting
temp_max = max(temp_data)
temp_min = min(temp_data)
max_tot = max(np.abs([temp_max, temp_min]))

print('Max Value: ' , temp_max)
print('Min Value: ' , temp_min)


## Plotting barcode graph with data
fig , ax1 = plt.subplots(figsize=(fig_width, fig_height))

im = ax1.imshow(temp_data.reshape(1, -1), aspect = 'auto', cmap = 'seismic', 
                vmin = -3, vmax = 3) 
                
                #used if there isn't a single outlier data point
                #vmin = ((max_tot * -1) - (max_tot) * 0.1), 
                #vmax = (max_tot + max_tot * 0.1))

ax1.set_yticks([])
ax1.set_xlabel('Year', fontsize = 14)

## Adding line plot on top of graph
if overlay == 'y':
    ax2 = ax1.twinx()
    ax2.plot(temp_data, color = 'yellow', linewidth = 3, marker = 'o', markersize = 10)
    ax2.set_xticks(np.arange(0, len(temp_data), tick_int))
    ax2.set_xticklabels(np.arange(startdates[0], startdates[-1], 10) , fontsize = 12)
    ax2.set_ylim(((max_tot * -1) - (max_tot * 0.1)), (max_tot + max_tot * 0.1))
    ax2.yaxis.set_ticks_position('left')
    ax2.set_ylabel('Temperature Anomaly (C)', fontsize = 14)
    ax2.yaxis.set_label_position('left')
elif overlay == 'n':
    ax1.set_xticks(np.arange(0, len(temp_data), 10))
    ax1.set_xticklabels(np.arange(startdates[0], startdates[-1], 10))


fig.colorbar(im).set_label('Temperature Anomaly (C)', fontsize = 14)
plt.xlim(0,len(temp_data))
plt.title("Berlin, Germany Normalized Temperature Anomalies 1876-2019", fontsize = 16)
plt.show()
